## 第二章 提供推荐
本章涉及单词
- collaborative filtering 协同过滤
- Euclidean distance 欧式距离
- critic 评论家
- user-based Collaborative filtering 基于用户的协同过滤
- item-based Collaborative filtering 基于物品的协同过滤
- unsupervised clustering algorithms 无监督聚类算法
- Tanimoto 谷本系数

本章涉及Python用法
- 文件读写
- plt画图（散点、拟合线）
- numpy计算
- pandas读取csv

#### 协作型过滤
- David Goldberg 1992年《Using collaborative filtering to weave an information tapestry》论文首次使用
- 一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一小群人。算法会对这些人所偏爱的其他内容进行考查，并将他们组合起来构造出一个经过排名的推荐列表。
##### 搜集偏好
数据集为一组用户对他们看过的电影的评分
##### 寻找相近的用户
###### 欧式距离
> 以2个电影（物品）为轴，将某个用户对这两个电影的评分形成坐标，表现在二维空间中

两个点之间的欧式距离计算公式：

$d = \sqrt[]{\displaystyle \sum^{N}_{i=1}{(x_i - y_i)^2}}$

为了获得一个0-1之间的值，一般取  `score = 1/(1 + d)`，距离越远，值越逼近0

###### 皮尔逊相关度评价
> 举例：以2个用户为轴，将他们对共同看过的电影的评分形成坐标点，标注每个电影的位置点，作出最佳拟合线，如果两人对于所有电影的评分情况都一致，这条线就会是一条对角线，并且会与所有点都香蕉
> 优点：与欧式距离相比，修正了“夸大分值”的情况，也就是【不同人对于物品打分的严谨程度的不一致】不会影响皮尔逊相关度

> 具体理解先要回忆一下方差和协方差

方差计算公式：
总体方差：
![Population variance formula](https://latex.codecogs.com/svg.image?\sigma^2=\frac{\sum_{i=1}^{N}(X_i-\mu)^2}{N})

样本方差（无偏估计）：
![Sample variance formula](https://latex.codecogs.com/svg.image?s^2=\frac{\sum_{i=1}^{n}(X_i-\bar{X})^2}{n-1})

其中，
- 对于总体方差，( $σ^2$ ) 表示方差，\( N \) 表示总体中的数据点数量，( $X_i$ ) 表示第 ( i ) 个数据点，(μ ) 表示总体均值。
- 
- 对于样本方差，( $s^2$) 表示方差，( n ) 表示样本中的数据点数量，( $X_i$ ) 表示第 ( i ) 个数据点，($\overline{x}$) 表示样本均值。
> 参考：https://www.cnblogs.com/zzdbullet/p/10087196.html

总体协方差计算公式：
![Population covariance formula](https://latex.codecogs.com/svg.image?\sigma_{XY}=\frac{\sum_{i=1}^{N}(X_i-\mu_X)(Y_i-\mu_Y)}{N})

样本协方差计算公式：
![Sample covariance formula](https://latex.codecogs.com/svg.image?Cov(X,Y)=\frac{\sum_{i=1}^{n}(X_i-\bar{X})(Y_i-\bar{Y})}{n-1})

Cov（协方差）存在的缺点是相关性会受到x，y实际数值大小的影响（其实是幅度），因此会出现，两对明明相关度相似的变量，结果数值相差很大。因此Pearson相关就在cov下除以xy标准差，把相关系数限定在了-1和1之间，方便&直观&牛逼

皮尔逊相对度计算公式，两个变量的协方差除以标准差，介于-1 ~ 1之间：
![Pearson's correlation coefficient formula](https://latex.codecogs.com/svg.image?r=\frac{\sum_{i=1}^{n}(X_i-\bar{X})(Y_i-\bar{Y})}{\sqrt{\sum_{i=1}^{n}(X_i-\bar{X})^2}\sqrt{\sum_{i=1}^{n}(Y_i-\bar{Y})^2}})

书中代码的计算公式（样本皮尔逊相关系数）结果一致：

![Pearson correlation coefficient](https://latex.codecogs.com/png.latex?r%20%3D%20%5Cfrac%7Bn%28%5Csum%20xy%29%20-%20%28%5Csum%20x%29%28%5Csum%20y%29%7D%7B%5Csqrt%7B%5Bn%5Csum%20x%5E2%20-%20%28%5Csum%20x%29%5E2%5D%5Bn%5Csum%20y%5E2%20-%20%28%5Csum%20y%29%5E2%5D%7D%7D)


##### 应该选用哪一种相似度度量方法
都值得一试，取决于具体的应用，一般的都会将相似度计算方法作为函数的一个入参进行设计，随时可以更改算法，供我们尝试

##### 为评论者打分
根据相似度计算公式，找到与指定用户相似的topN个用户，这里没有判断正负，有可能是负相关

##### 推荐物品
与我相似的n个用户，通过公式：
`sum(u-u相似度 * u->m评分) / sum(u-u相似度)`
推算出他们看过但是我还没看过的电影，我可能的评分数，然后按照分数倒排进行推荐给我

##### 匹配商品
将数据集中的人与电影互换，数据集变成了一组电影，以及看过它的人以及评分
使用同样的方式，便可以计算出电影的相似度，找到相似的topN其他电影，以及为电影推荐相关的用户
将人和物对调，并不总会得到有价值的结果，但是大多数情况下，这将有助于我们作出有意义的对比。举例打折促销活动，就可以通过物找人。


#### 构建一个基于del.icio.us的链接推荐系统
##### 构造数据集
文章通过查询del.icio.us获取指定tag最受欢迎的5个链接，然后查询张贴了这些链接的用户（每个链接只返回30个用户），然后挨个查询这些用户张贴的链接，构造了一个数据集。

因为如今del.icio.us已经无法访问，这里我让GPT生成了30个用户，100个网址，随机分配每个用户5-20个链接，构造相同格式的数据集，进行测试。

这种场景的数据与电影数据相比没有评分，只有是否张贴了某个链接，用0、1表示，所以计算时，每个用户构造了一个类似[1,0,1,0]的向量，元素个数=链接总数，进行相似度计算。
（担忧：当物品数据量非常大的时候，这个计算恐怕无法完成。）
##### 推荐近邻与链接
1. 使用这个数据集，一样可以找到指定用户的topN相似用户，以及给用户推荐链接
2. 同样将链接和用户对调之后，使用相同的函数，可以给指定链接，推荐相似的链接
##### 基于物品的过滤
###### 构造数据集
遍历所有物品，将每个物品最相似的n个物品缓存起来，函数`calculate_similar_items`
###### 获得推荐
`get_recommanded_items`
遍历指定用户评分过的物品，将这些物品相似的top n物品查出，然后使用公式
`sum(i-i相似度 * u->i评分) / sum(i-i相似度)`
推算出对应物品我可能的评分，按照评分排序后进行推荐

##### 使用MovieLens数据集
从movieLens网站上下载数据集，直接使用刚刚前面编写好的程序进行推荐

##### 基于用户还是物品进行过滤
1. 大数据集，基于物品过滤更快，但是需要维护数据（额外开销）
2. 对于稀疏数据集，基于物品的过滤方法，通常要优于基于用户的过滤方法
3. 对于密集数据集，两者几乎一样
4. 基于用户更易实现，通常适用于规模较小的变化非常频繁的内存数据集

#### 课后习题
1. Tanimoto分值
> 求出 Tanimoto 相化度评价值。在何种情况下，我们可以将该方法作为相似性的度量方法，用以替代欧几里德距离法或皮尔逊系数法？请利用 Tanimoro 分值建立一个新的相似度函数。 

```
	T = C / (A + B - C)
	A 是集合A的元素数量
	B 是集合B的元素数量
	C 是集合A和集合B的交集元素数量
	
	一般用于计算拥有一组标签的两个物品的相似度
```

---

2. 标签相似度
> 请使用del.icio.us API 构造一个涉及标签和链接的数据集。利用它来计算不同标签间的相似度，看一看是否能找到相似度几乎一样的情况。请找出某些本该被标记为 “programming”，但却没被标记的链接。

```
因为del.icio.us无法正常访问了，这里说一下解题思路
1. 首先构造{标签-[链接]}的数据集，一个标签关联多个链接；
2. 相似度计算：
	a. 使用前面的方式也可以，构造一个长度为链接总数的数组，用0,1表示是否关联某链接，然后使用top_matches计算指定标签的相似标签
	b. 使用第一题刚了解到的Tanimoto分值算法，两个标签共同的链接数 / 两个标签的并集数，相似度为1则表示完全一样
	c. 给programming标签推荐链接（前文的recommendations.get_recommendations函数），观察相似度和链接内容，即可找出本该标记为programming但是没有的标签
```
---- 

3. 基于用户的算法执行效率
> 由于基于用户的过滤算法，在每次须要推荐时，都会将某位用户与其他所有用户进行比较，故而效率低下。请编写一个预先计算用户相似度的函数，井修改涉及推荐的相关代码，只取出当前用户外的其他前5 名用户来给出推荐。

```
预先计算每位用户的相似用户，存储到文件中，使用时直接读取
每次获取推荐时，从缓存的5个相似用户进行推荐即可
具体实现逻辑见 homework.py 中的 calculate_similar_users 和 get_recommendations 函数
```

--------

4. 基于物品的书签过滤
> 请从 del.icio.us 网站下载一组数据，并将其加入数据集中。建立一张"物一物"表，并利用它为不同用户提供基于物品的推荐。将之与基于用户的推荐做一个对比。 

```
不太理解题干

```

--- 

5.  Audioscrobbler 
> 请访问 http://www.audioscrobbler.net 该网站拥有一个由大群用户的音乐偏好所构成的数据集。利用网站提供的 Web Services API获取一组数报，并以此来构造一个音乐推荐系统。

```
网站已经无法访问，但是思路应该跟{标签-[链接]}基本一致，因为这里同样没有评分，只有是否偏好：
1. 获取{用户-[音乐列表]}的数据集，进行用户相似度的计算
2. 将数据集反转，构造{音乐-[用户列表]}的数据集，进行物品的相似度计算
3. 这里可以使用 向量计算 或 Tanimoto 

```